import pandas as pd
import numpy as np

# Создание примера данных для демонстрации
data = {
    'Столбец': [10, 5, 8, 12, 3],
    'Другой столбец': [True, False, True, False, True],
    'Категориальный столбец': ['A', 'B', 'A', 'C', 'B']
}
df = pd.DataFrame(data)

# Сохранение данных в CSV файл для демонстрации
df.to_csv('example_data.csv', index=False)
print("Пример данных успешно сохранен в файл example_data.csv")

# 1. Загрузка данных из CSV файла
df = pd.read_csv('example_data.csv')
print(df) # Просмотр данных

# 2. Основные методы работы с данными

# Просмотр первых 3 строк данных для ознакомления с содержимым
print("\nПервые 3 строки данных:")
print(df.head(3)) # дефолтное значение = 5

# Проверка общей информации о данных в датафрейме
print("\nОбщая информация о данных:")
print(df.info())

# Просмотр названий столбцов
print("\nНазвания столбцов:")
print(df.columns)

# Просмотр типов данных в столбцах
print("\nТипы данных в столбцах:")
print(df.dtypes)

# Подсчет количества строк и столбцов в датафрейме
num_rows, num_cols = df.shape
print(f"\nДанные содержат {num_rows} строк и {num_cols} столбцов.")

# Просмотр базовых статистических характеристик числовых данных
print("\nОсновные статистические характеристики числовых данных:")
print(df.describe())
print("только минимальное значение:", df.describe().loc['min']) # выводит только минимальное значение 


# 3. Фильтрация и сортировка данных

# Сортировка данных по убыванию значения столбца 'Столбец'
sorted_data = df.sort_values(by='Столбец', ascending=False)
# параметр by='Столбец' указывает на столбец, по которому происходит сортировка,
# ascending=False означает сортировку по убыванию. По умолчанию ascending=True (по возрастанию).
print("\nОтсортированные данные по убыванию столбца 'Столбец':")
print(sorted_data)

# Фильтрация данных по условию в одном столбце
filtered_data = df[df['Столбец'] > 5]
# Фильтрация данных, где значение в столбце 'Столбец' больше 5
print("\nОтфильтрованные данные, где 'Столбец' > 5:")
print(filtered_data)


# 4. Группировка и агрегация данных

# Группировка данных по категориальному столбцу и вычисление среднего значения столбца 'Столбец'
grouped_data = df.groupby('Категориальный столбец')['Столбец'].mean()
# Группировка данных по столбцу 'Категориальный столбец' (группирует строки по уникальным значениям) и вычисление среднего значения столбца 'Столбец'
print("\nСгруппированные данные по 'Категориальный столбец' среднее 'Столбец':")
print(grouped_data)


# Группировка данных с множественными функциями агрегации
grouped_stats = df.groupby('Категориальный столбец').agg({
    'Столбец': ['mean', 'median', 'max'],
    'Другой столбец': 'sum'
})
print("\nГруппировка данных с множественными функциями агрегации")
print(grouped_stats)


# 5. Обработка пропущенных значений
# Создание примера данных для демонстрации с пропущенными значениями
data = {
    'Столбец': [10, np.nan, 8, 12, np.nan],
    'Другой столбец': [True, False, np.nan, False, True],
    'Категориальный столбец': ['A', 'B', 'A', None, 'B']
}
df = pd.DataFrame(data)

# Подсчет количества пропущенных значений в каждом столбце
missing_values = df.isnull().sum()
print("\nКоличество пропущенных значений в каждом столбце:")
print(missing_values)

# Проверка наличия пропущенных значений в DataFrame
if missing_values.any() > 0:  # .any() возвращает True, если есть хотя бы одно пропущенное значение
    pd.set_option('future.no_silent_downcasting', True)
    # Дополнительное заполнение оставшихся пропущенных значений
    df_filled = df.fillna({
        'Столбец': df['Столбец'].mean(),  # Заполнение средним значением для числового столбца
        'Другой столбец': False,  # Заполнение False для булевого столбца
        'Категориальный столбец': 'Заполнено'  # Заполнение строкой для категориального столбца
    })

    print("\nDataFrame после дополнительного заполнения пропущенных значений:")
    print(df_filled)
else:
    print("\nНет пропущенных значений в DataFrame.")


# Создание второго примера данных для демонстрации с удалением строк, содержащих пропущенные значения
data2 = {
    'Столбец': [15, np.nan, 7, 11, np.nan],
    'Другой столбец': [False, True, True, False, np.nan],
    'Категориальный столбец': [None, 'C', 'D', 'E', 'F']
}
df2 = pd.DataFrame(data2)

# Подсчет количества пропущенных значений в каждом столбце для второго примера
missing_values2 = df2.isnull().sum()
print("\nКоличество пропущенных значений во втором DataFrame:")
print(missing_values2)

# Проверка наличия пропущенных значений в DataFrame
if missing_values2.any() > 0:  # .any() возвращает True, если есть хотя бы одно пропущенное значение
    # Удаление строк с пропущенными значениями
    df2_cleaned = df2.dropna()
    print("\nDataFrame после удаления строк с пропущенными значениями:")
    print(df2_cleaned)
else:
    print("\nНет пропущенных значений в DataFrame.")


df = pd.read_csv('example_data.csv') # возвращаем в предыдущее значение


# 6. Работа с текстовыми данными

# Преобразование категориального столбца в верхний регистр
df['Категориальный столбец'] = df['Категориальный столбец'].str.upper()
# Приведение значений столбца 'Категориальный столбец' к верхнему регистру
print("\nПреобразование категориального столбца к верхнему регистру:")
print(df)

# Противоположная функция: преобразование категориального столбца к нижнему регистру
df['Категориальный столбец'] = df['Категориальный столбец'].str.lower()
# Приведение значений столбца 'Категориальный столбец' к нижнему регистру
print("\nПреобразование категориального столбца к нижнему регистру:")
print(df)

# Поиск строк по подстроке 'A'
filtered_data = df[df['Категориальный столбец'].str.contains('a', na=False)]
# Фильтрация данных, где столбец 'Столбец' содержит подстроку 'A', с игнорированием пропущенных значений (параметром na=False)
print("\nОтфильтрованные данные по подстроке 'a' с параметром na=False:")
print(filtered_data)


# 7. Сохранение данных

# Сохранение обработанных данных в новый CSV файл
filtered_data.to_csv('filtered_data.csv', index=False)
print("\nОтфильтрованные данные успешно сохранены в файл filtered_data.csv")


# 8. Дополнительные функции

# Определение пользовательской функции
def custom_function(x):
    return x * 2

# Применение пользовательской функции к столбцу 'Столбец'
df['Удвоенный столбец'] = df['Столбец'].apply(custom_function)
# Применение функции custom_function к каждому значению в столбце 'Столбец' и сохранение результата в новый столбец 'Удвоенный столбец'

# Просмотр данных после применения пользовательской функции
print("Данные после применения пользовательской функции:")
print(df)

